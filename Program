
"""
LinkDock (full working) — Tkinter desktop organizer for:

✅ Tiered categories (parent/child)
✅ Save LINKS (title + URL) + editable notes
✅ Save FILES of ANY type (PDF/DOCX/etc.) by COPYING into a managed container folder
✅ Create internal lightweight files (notes/log) inside the container folder (.md by default)
✅ Quick actions: Open, Copy, Open Folder, Email (Outlook attach on Windows), Delete
✅ Edit notes with basic formatting (Bold / Highlight / Font size) stored in db.json

Run:
  python linkdock.py

Outlook attachment support (Windows):
  pip install pywin32

Build EXE (Windows):
  pip install pyinstaller
  pyinstaller --noconsole --onefile --name LinkDock linkdock.py
"""

import json
import os
import re
import shutil
import sys
import time
import uuid
import webbrowser
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Any, Optional, Tuple, List

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import tkinter.font as tkfont


# ----------------------------
# Storage / Paths
# ----------------------------

APP_NAME = "LinkDock"
APP_DIR = Path.home() / ".linkdock"
DB_PATH = APP_DIR / "db.json"
FILES_DIR = APP_DIR / "files"


def ensure_dirs():
    APP_DIR.mkdir(parents=True, exist_ok=True)
    FILES_DIR.mkdir(parents=True, exist_ok=True)


def now_iso():
    return time.strftime("%Y-%m-%d %H:%M:%S")


def safe_filename(name: str, max_len: int = 120) -> str:
    name = (name or "").strip()
    name = re.sub(r"[^\w\-. ()\[\]]+", "_", name)
    name = re.sub(r"\s+", " ", name).strip()
    if not name:
        name = "file"
    return name[:max_len]


def is_windows() -> bool:
    return sys.platform.startswith("win")


def open_path(path: Path):
    try:
        if is_windows():
            os.startfile(str(path))  # type: ignore[attr-defined]
        elif sys.platform == "darwin":
            import subprocess
            subprocess.run(["open", str(path)], check=False)
        else:
            import subprocess
            subprocess.run(["xdg-open", str(path)], check=False)
    except Exception as e:
        messagebox.showerror(APP_NAME, f"Could not open:\n{path}\n\n{e}")


def open_folder_containing(file_path: Path):
    if not file_path.exists():
        messagebox.showwarning(APP_NAME, "File does not exist on disk.")
        return
    open_path(file_path.parent)


def copy_to_clipboard(root: tk.Tk, text: str):
    root.clipboard_clear()
    root.clipboard_append(text)
    root.update()


# ----------------------------
# Outlook email (Windows)
# ----------------------------

def outlook_new_mail(subject: str, body: str, attach_path: Optional[str] = None):
    """
    Creates an Outlook draft email. Windows only.
    Requires: pip install pywin32
    """
    try:
        import win32com.client  # type: ignore
    except Exception as e:
        messagebox.showerror(
            APP_NAME,
            "Outlook integration requires pywin32.\n\nInstall:\n  pip install pywin32\n\n"
            f"Error:\n{e}"
        )
        return

    try:
        outlook = win32com.client.Dispatch("Outlook.Application")
        mail = outlook.CreateItem(0)  # 0 = olMailItem
        mail.Subject = subject
        mail.Body = body
        if attach_path and os.path.exists(attach_path):
            mail.Attachments.Add(attach_path)
        mail.Display(True)
    except Exception as e:
        messagebox.showerror(APP_NAME, f"Could not create Outlook email:\n\n{e}")


# ----------------------------
# DB
# ----------------------------

def new_id(prefix: str) -> str:
    return f"{prefix}_{uuid.uuid4().hex[:12]}"


def default_db() -> Dict[str, Any]:
    root_id = "cat_root"
    return {
        "version": 2,
        "categories": {
            root_id: {
                "id": root_id,
                "name": "My Dock",
                "parent_id": None,
                "created_at": now_iso(),
            }
        },
        "items": {}
    }


def load_db() -> Dict[str, Any]:
    ensure_dirs()
    if not DB_PATH.exists():
        db = default_db()
        save_db(db)
        return db

    try:
        with DB_PATH.open("r", encoding="utf-8") as f:
            db = json.load(f)
        if "categories" not in db or "items" not in db:
            raise ValueError("Invalid DB format")
        return db
    except Exception:
        backup = DB_PATH.with_suffix(".json.bak")
        try:
            shutil.copy2(DB_PATH, backup)
        except Exception:
            pass
        db = default_db()
        save_db(db)
        return db


def save_db(db: Dict[str, Any]):
    ensure_dirs()
    tmp = DB_PATH.with_suffix(".json.tmp")
    with tmp.open("w", encoding="utf-8") as f:
        json.dump(db, f, indent=2, ensure_ascii=False)
    tmp.replace(DB_PATH)


def category_children(db: Dict[str, Any], parent_id: str):
    for cid, c in db["categories"].items():
        if c.get("parent_id") == parent_id:
            yield cid, c


def item_children(db: Dict[str, Any], category_id: str):
    for iid, it in db["items"].items():
        if it.get("category_id") == category_id:
            yield iid, it


def get_category_path_names(db: Dict[str, Any], category_id: str) -> str:
    parts: List[str] = []
    cur = category_id
    while cur:
        c = db["categories"].get(cur)
        if not c:
            break
        parts.append(c["name"])
        cur = c.get("parent_id")
    return " / ".join(reversed(parts))


def category_folder_path(db: Dict[str, Any], category_id: str) -> Path:
    parts: List[str] = []
    cur = category_id
    while cur:
        c = db["categories"].get(cur)
        if not c:
            break
        parts.append(safe_filename(c["name"]))
        cur = c.get("parent_id")
    parts = list(reversed(parts))
    folder = FILES_DIR.joinpath(*parts)
    folder.mkdir(parents=True, exist_ok=True)
    return folder


# ----------------------------
# Rich notes helpers
# ----------------------------

def extract_text_with_tags(text_widget: tk.Text) -> Tuple[str, List[Dict[str, str]]]:
    plain = text_widget.get("1.0", "end-1c")
    tags: List[Dict[str, str]] = []
    for tag in text_widget.tag_names():
        if tag in ("sel",):
            continue
        ranges = text_widget.tag_ranges(tag)
        for i in range(0, len(ranges), 2):
            tags.append({"tag": tag, "start": str(ranges[i]), "end": str(ranges[i + 1])})
    return plain, tags


def apply_text_with_tags(text_widget: tk.Text, plain: str, tags: List[Dict[str, str]]):
    text_widget.delete("1.0", "end")
    text_widget.insert("1.0", plain or "")
    for t in tags or []:
        try:
            text_widget.tag_add(t["tag"], t["start"], t["end"])
        except Exception:
            pass


# ----------------------------
# UI
# ----------------------------

@dataclass
class Selection:
    kind: str  # "category" or "item"
    id: str


class LinkDockApp:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title(APP_NAME)
        self.root.geometry("1180x720")
        self.root.minsize(980, 600)

        self.db = load_db()
        self.selected: Optional[Selection] = None

        self._build_style()
        self._build_layout()
        self._bind_shortcuts()
        self.refresh_tree(select_id="cat_root")

    def _build_style(self):
        style = ttk.Style(self.root)
        try:
            if is_windows():
                style.theme_use("vista")
        except Exception:
            pass
        style.configure("TButton", padding=(10, 6))
        style.configure("Header.TLabel", font=("Segoe UI", 12, "bold"))
        style.configure("Muted.TLabel", foreground="#555")
        style.configure("Sub.TLabel", font=("Segoe UI", 10))

    def _build_layout(self):
        top = ttk.Frame(self.root, padding=10)
        top.pack(side=tk.TOP, fill=tk.X)

        self.search_var = tk.StringVar()
        self.search_entry = ttk.Entry(top, textvariable=self.search_var, width=40)
        self.search_entry.pack(side=tk.LEFT, padx=(0, 8))
        self.search_entry.insert(0, "Search…")
        self.search_entry.bind("<FocusIn>", lambda e: self._clear_search_hint())
        self.search_entry.bind("<KeyRelease>", lambda e: self.refresh_tree())

        ttk.Button(top, text="New Category", command=self.new_category).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="New Link", command=self.new_link).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="Add File…", command=self.add_file).pack(side=tk.LEFT, padx=4)
        ttk.Button(top, text="New Note File…", command=self.new_note_file).pack(side=tk.LEFT, padx=4)

        ttk.Separator(self.root).pack(fill=tk.X)

        main = ttk.Panedwindow(self.root, orient=tk.HORIZONTAL)
        main.pack(fill=tk.BOTH, expand=True)

        # Left: tree
        left = ttk.Frame(main, padding=10)
        main.add(left, weight=2)

        self.tree = ttk.Treeview(left, columns=("type",), show="tree headings", selectmode="browse")
        self.tree.heading("#0", text="Workspace")
        self.tree.heading("type", text="Type")
        self.tree.column("type", width=130, anchor="w")
        self.tree.pack(fill=tk.BOTH, expand=True)

        yscroll = ttk.Scrollbar(left, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=yscroll.set)
        yscroll.place(relx=1.0, rely=0.0, relheight=1.0, anchor="ne")

        self.tree.bind("<<TreeviewSelect>>", self.on_tree_select)
        self.tree.bind("<Double-1>", self.on_tree_double_click)
        self.tree.bind("<Button-3>", self.on_tree_right_click)

        # Right: details
        right = ttk.Frame(main, padding=14)
        main.add(right, weight=3)

        self.detail_title = ttk.Label(right, text="Select something", style="Header.TLabel")
        self.detail_title.pack(anchor="w")

        self.detail_sub = ttk.Label(right, text="", style="Muted.TLabel")
        self.detail_sub.pack(anchor="w", pady=(2, 10))

        self.detail_text = tk.Text(
            right,
            height=14,
            wrap="word",
            relief="solid",
            borderwidth=1,
            font=("Segoe UI", 10),
        )
        self.detail_text.pack(fill=tk.BOTH, expand=True)
        self.detail_text.configure(state="disabled")

        actions = ttk.Frame(right)
        actions.pack(fill=tk.X, pady=(10, 0))

        self.btn_open = ttk.Button(actions, text="Open", command=self.action_open, state="disabled")
        self.btn_open.pack(side=tk.LEFT, padx=4)

        self.btn_copy = ttk.Button(actions, text="Copy", command=self.action_copy, state="disabled")
        self.btn_copy.pack(side=tk.LEFT, padx=4)

        self.btn_folder = ttk.Button(actions, text="Open Folder", command=self.action_open_folder, state="disabled")
        self.btn_folder.pack(side=tk.LEFT, padx=4)

        self.btn_email = ttk.Button(actions, text="Email…", command=self.action_email, state="disabled")
        self.btn_email.pack(side=tk.LEFT, padx=4)

        self.btn_edit_notes = ttk.Button(actions, text="Edit Notes…", command=self.action_edit_notes, state="disabled")
        self.btn_edit_notes.pack(side=tk.LEFT, padx=4)

        self.btn_delete = ttk.Button(actions, text="Delete", command=self.action_delete, state="disabled")
        self.btn_delete.pack(side=tk.RIGHT, padx=4)

        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status = ttk.Label(self.root, textvariable=self.status_var, padding=(10, 6), style="Sub.TLabel")
        status.pack(side=tk.BOTTOM, fill=tk.X)

    def _bind_shortcuts(self):
        self.root.bind_all("<Control-c>", lambda e: self.action_copy())
        self.root.bind_all("<Control-o>", lambda e: self.action_open())
        self.root.bind_all("<Delete>", lambda e: self.action_delete())

    def _clear_search_hint(self):
        if self.search_var.get() == "Search…":
            self.search_var.set("")

    # ----------------------------
    # Tree handling
    # ----------------------------

    def refresh_tree(self, select_id: Optional[str] = None):
        query = self.search_var.get().strip()
        if query == "Search…":
            query = ""
        q = query.lower()

        self.tree.delete(*self.tree.get_children(""))

        root_id = "cat_root"
        root_node = self._insert_category_node("", root_id)

        def add_category_recursive(parent_tree_node: str, cat_id: str):
            for child_id, _c in sorted(category_children(self.db, cat_id), key=lambda x: x[1]["name"].lower()):
                node = self._insert_category_node(parent_tree_node, child_id)
                add_category_recursive(node, child_id)

            for item_id, it in sorted(item_children(self.db, cat_id), key=lambda x: (x[1].get("title", "") or "").lower()):
                if q:
                    hay = (
                        f"{it.get('title','')} {it.get('url','')} "
                        f"{it.get('notes_plain','')} {it.get('notes','')} {it.get('path','')}"
                    ).lower()
                    if q not in hay:
                        continue
                self._insert_item_node(parent_tree_node, item_id)

        add_category_recursive(root_node, root_id)
        self.tree.item(root_node, open=True)

        if select_id:
            self._select_by_id(select_id)

    def _insert_category_node(self, parent_node: str, cat_id: str) -> str:
        c = self.db["categories"][cat_id]
        tree_id = f"cat::{cat_id}"
        return self.tree.insert(parent_node, "end", iid=tree_id, text=c["name"], values=("Category",))

    def _insert_item_node(self, parent_node: str, item_id: str) -> str:
        it = self.db["items"][item_id]
        tree_id = f"item::{item_id}"
        itype = it["type"].capitalize()
        title = it.get("title") or it.get("url") or it.get("path") or "Untitled"
        return self.tree.insert(parent_node, "end", iid=tree_id, text=title, values=(itype,))

    def _select_by_id(self, raw_id: str):
        if raw_id.startswith("cat_") or raw_id == "cat_root":
            tree_id = f"cat::{raw_id}"
        else:
            tree_id = f"item::{raw_id}"
        if self.tree.exists(tree_id):
            self.tree.selection_set(tree_id)
            self.tree.see(tree_id)

    def on_tree_select(self, _event=None):
        sel = self.tree.selection()
        if not sel:
            self.selected = None
            self._render_details()
            return

        iid = sel[0]
        if iid.startswith("cat::"):
            self.selected = Selection(kind="category", id=iid.split("::", 1)[1])
        elif iid.startswith("item::"):
            self.selected = Selection(kind="item", id=iid.split("::", 1)[1])
        else:
            self.selected = None

        self._render_details()

    def on_tree_double_click(self, _event=None):
        if not self.selected:
            return
        if self.selected.kind == "category":
            tree_id = f"cat::{self.selected.id}"
            is_open = bool(self.tree.item(tree_id, "open"))
            self.tree.item(tree_id, open=not is_open)
        else:
            self.action_open()

    def on_tree_right_click(self, event):
        iid = self.tree.identify_row(event.y)
        if iid and self.tree.exists(iid):
            self.tree.selection_set(iid)
            self.on_tree_select()

        menu = tk.Menu(self.root, tearoff=0)
        menu.add_command(label="New Category", command=self.new_category)
        menu.add_command(label="New Link", command=self.new_link)
        menu.add_command(label="Add File…", command=self.add_file)
        menu.add_command(label="New Note File…", command=self.new_note_file)
        menu.add_separator()
        menu.add_command(label="Open", command=self.action_open)
        menu.add_command(label="Copy", command=self.action_copy)
        menu.add_command(label="Open Folder", command=self.action_open_folder)
        menu.add_command(label="Email…", command=self.action_email)
        menu.add_command(label="Edit Notes…", command=self.action_edit_notes)
        menu.add_separator()
        menu.add_command(label="Delete", command=self.action_delete)

        try:
            menu.tk_popup(event.x_root, event.y_root)
        finally:
            menu.grab_release()

    # ----------------------------
    # Details panel
    # ----------------------------

    def _render_details(self):
        self.detail_text.configure(state="normal")
        self.detail_text.delete("1.0", tk.END)

        for b in (self.btn_open, self.btn_copy, self.btn_folder, self.btn_email, self.btn_delete, self.btn_edit_notes):
            b.configure(state="disabled")

        if not self.selected:
            self.detail_title.configure(text="Select something")
            self.detail_sub.configure(text="")
            self.detail_text.configure(state="disabled")
            return

        if self.selected.kind == "category":
            c = self.db["categories"][self.selected.id]
            path = get_category_path_names(self.db, self.selected.id)
            folder = category_folder_path(self.db, self.selected.id)

            self.detail_title.configure(text=c["name"])
            self.detail_sub.configure(text=f"Category • {path}")

            self.detail_text.insert(tk.END, f"Created: {c.get('created_at','')}\n")
            self.detail_text.insert(tk.END, f"Folder: {folder}\n\n")
            self.detail_text.insert(
                tk.END,
                "Workflow:\n"
                "- Add File… to copy PDF/DOCX/etc into this folder\n"
                "- New Note File… to create internal notes/log files here\n"
                "- Open / Open Folder to jump to the container folder\n"
            )

            self.btn_open.configure(state="normal")
            self.btn_copy.configure(state="normal")
            self.btn_folder.configure(state="normal")
            self.btn_email.configure(state="normal")
            self.btn_delete.configure(state="normal")
        else:
            it = self.db["items"].get(self.selected.id)
            if not it:
                self.detail_title.configure(text="Missing item")
                self.detail_sub.configure(text="")
                self.detail_text.insert(tk.END, "This item is missing from the database.")
                self.detail_text.configure(state="disabled")
                return

            itype = it["type"]
            title = it.get("title") or "Untitled"
            self.detail_title.configure(text=title)
            self.detail_sub.configure(text=f"{itype.capitalize()} • {get_category_path_names(self.db, it['category_id'])}")

            self.detail_text.insert(tk.END, f"Created: {it.get('created_at','')}\n")
            if itype == "link":
                self.detail_text.insert(tk.END, f"URL: {it.get('url','')}\n")
            else:
                self.detail_text.insert(tk.END, f"File: {it.get('path','')}\n")
            self.detail_text.insert(tk.END, "\n")

            notes_plain = it.get("notes_plain", it.get("notes", "")) or ""
            self.detail_text.insert(tk.END, "Notes (preview):\n")
            self.detail_text.insert(tk.END, notes_plain.strip() if notes_plain.strip() else "(none)")
            self.detail_text.insert(tk.END, "\n")

            self.btn_open.configure(state="normal")
            self.btn_copy.configure(state="normal")
            self.btn_email.configure(state="normal")
            self.btn_edit_notes.configure(state="normal")
            self.btn_delete.configure(state="normal")
            if itype == "file":
                self.btn_folder.configure(state="normal")

        self.detail_text.configure(state="disabled")

    # ----------------------------
    # Context helpers
    # ----------------------------

    def current_category_id(self) -> str:
        if self.selected and self.selected.kind == "category":
            return self.selected.id
        if self.selected and self.selected.kind == "item":
            return self.db["items"][self.selected.id]["category_id"]
        return "cat_root"

    # ----------------------------
    # Create actions
    # ----------------------------

    def new_category(self):
        parent_id = self.current_category_id()
        name = self._prompt("New Category", "Category name:")
        if not name:
            return

        cid = new_id("cat")
        self.db["categories"][cid] = {
            "id": cid,
            "name": name.strip(),
            "parent_id": parent_id,
            "created_at": now_iso(),
        }
        save_db(self.db)
        self.status_var.set("Category created.")
        self.refresh_tree(select_id=cid)

    def new_link(self):
        cat_id = self.current_category_id()
        dialog = LinkDialog(self.root, title="New Link")
        result = dialog.show()
        if not result:
            return
        title, url, notes = result

        url = url.strip()
        if not url.lower().startswith(("http://", "https://")):
            url = "https://" + url

        iid = new_id("item")
        self.db["items"][iid] = {
            "id": iid,
            "type": "link",
            "category_id": cat_id,
            "title": title.strip() if title else url,
            "url": url,
            "notes_plain": notes.strip(),
            "notes": notes.strip(),        # backward compatibility
            "notes_tags": [],              # for rich notes
            "created_at": now_iso(),
        }
        save_db(self.db)
        self.status_var.set("Link saved.")
        self.refresh_tree(select_id=iid)

    def add_file(self):
        cat_id = self.current_category_id()
        src = filedialog.askopenfilename(title="Choose a file to add")
        if not src:
            return

        src_path = Path(src)
        if not src_path.exists():
            messagebox.showerror(APP_NAME, "File does not exist.")
            return

        title = self._prompt("File Title", "Title (optional):", default=src_path.name)
        notes = self._prompt("File Notes", "Notes (optional):", default="") or ""

        dest_folder = category_folder_path(self.db, cat_id)
        dest_name = safe_filename(src_path.stem) + src_path.suffix
        dest_path = dest_folder / dest_name

        if dest_path.exists():
            base = safe_filename(src_path.stem)
            suffix = src_path.suffix
            for n in range(1, 1000):
                candidate = dest_folder / f"{base} ({n}){suffix}"
                if not candidate.exists():
                    dest_path = candidate
                    break

        try:
            shutil.copy2(src_path, dest_path)
        except Exception as e:
            messagebox.showerror(APP_NAME, f"Failed to copy file:\n{e}")
            return

        iid = new_id("item")
        self.db["items"][iid] = {
            "id": iid,
            "type": "file",
            "category_id": cat_id,
            "title": (title.strip() if title else dest_path.name),
            "path": str(dest_path),
            "notes_plain": notes.strip(),
            "notes": notes.strip(),
            "notes_tags": [],
            "created_at": now_iso(),
        }
        save_db(self.db)
        self.status_var.set("File added (copied into your LinkDock container folder).")
        self.refresh_tree(select_id=iid)

    def new_note_file(self):
        """
        Creates a lightweight internal file in the category's container folder,
        and saves it as a file-item so it can be opened/attached/emailed.
        """
        cat_id = self.current_category_id()
        folder = category_folder_path(self.db, cat_id)

        name = self._prompt("New Note File", "File name (without extension):", default="notes")
        if not name:
            return

        ext = ".md"  # change to ".txt" if you prefer
        filename = safe_filename(name) + ext
        path = folder / filename

        if path.exists():
            base = safe_filename(name)
            for n in range(1, 1000):
                candidate = folder / f"{base} ({n}){ext}"
                if not candidate.exists():
                    path = candidate
                    break

        try:
            path.write_text(f"# {name}\n\nCreated: {now_iso()}\n\n", encoding="utf-8")
        except Exception as e:
            messagebox.showerror(APP_NAME, f"Could not create file:\n\n{e}")
            return

        iid = new_id("item")
        self.db["items"][iid] = {
            "id": iid,
            "type": "file",
            "category_id": cat_id,
            "title": path.name,
            "path": str(path),
            "notes_plain": "",
            "notes": "",
            "notes_tags": [],
            "created_at": now_iso(),
        }
        save_db(self.db)
        self.status_var.set("Note file created.")
        self.refresh_tree(select_id=iid)
        open_path(path)

    # ----------------------------
    # Action buttons
    # ----------------------------

    def action_open(self):
        if not self.selected:
            return

        if self.selected.kind == "category":
            open_path(category_folder_path(self.db, self.selected.id))
            return

        it = self.db["items"].get(self.selected.id)
        if not it:
            return

        if it["type"] == "link":
            webbrowser.open(it.get("url", ""))
        else:
            p = Path(it.get("path", ""))
            if not p.exists():
                messagebox.showwarning(APP_NAME, "File not found on disk.")
                return
            open_path(p)

    def action_copy(self):
        if not self.selected:
            return

        if self.selected.kind == "category":
            folder = category_folder_path(self.db, self.selected.id)
            copy_to_clipboard(self.root, str(folder))
            self.status_var.set("Folder path copied.")
            return

        it = self.db["items"].get(self.selected.id)
        if not it:
            return

        if it["type"] == "link":
            copy_to_clipboard(self.root, it.get("url", ""))
            self.status_var.set("URL copied.")
        else:
            copy_to_clipboard(self.root, it.get("path", ""))
            self.status_var.set("File path copied.")

    def action_open_folder(self):
        if not self.selected:
            return

        if self.selected.kind == "category":
            open_path(category_folder_path(self.db, self.selected.id))
            return

        it = self.db["items"].get(self.selected.id)
        if not it or it["type"] != "file":
            return

        p = Path(it.get("path", ""))
        open_folder_containing(p)

    def action_email(self):
        """
        - Windows: Outlook draft + attach selected file item automatically (pywin32)
        - Others: mailto fallback (no attachments)
        """
        if not self.selected:
            return

        subject = f"{APP_NAME} Share"
        attach = None

        if self.selected.kind == "category":
            folder = str(category_folder_path(self.db, self.selected.id))
            body = f"Folder:\n{folder}\n"
        else:
            it = self.db["items"].get(self.selected.id)
            if not it:
                return
            notes = it.get("notes_plain", it.get("notes", "")) or ""

            if it["type"] == "file":
                attach = it.get("path")
                body = f"{it.get('title','')}\n\nNotes:\n{notes}\n\nPath:\n{attach}\n"
            else:
                url = it.get("url", "")
                body = f"{it.get('title','')}\n{url}\n\nNotes:\n{notes}\n"

        if is_windows():
            outlook_new_mail(subject, body, attach_path=attach)
            return

        import urllib.parse
        mailto = "mailto:?" + urllib.parse.urlencode({"subject": subject, "body": body})
        webbrowser.open(mailto)

    def action_edit_notes(self):
        if not self.selected or self.selected.kind != "item":
            return

        it = self.db["items"].get(self.selected.id)
        if not it:
            return

        dlg = RichNotesDialog(
            self.root,
            title="Edit Notes",
            initial_plain=it.get("notes_plain", it.get("notes", "")),
            initial_tags=it.get("notes_tags", []),
        )
        res = dlg.show()
        if not res:
            return

        plain, tags = res
        it["notes_plain"] = plain
        it["notes_tags"] = tags
        it["notes"] = plain  # backward compatibility

        save_db(self.db)
        self.status_var.set("Notes updated.")
        self._render_details()

    def action_delete(self):
        if not self.selected:
            return

        if self.selected.kind == "category":
            cid = self.selected.id
            if cid == "cat_root":
                messagebox.showinfo(APP_NAME, "You can’t delete the root category.")
                return

            has_subcats = any(True for _ in category_children(self.db, cid))
            has_items = any(True for _ in item_children(self.db, cid))

            if has_subcats or has_items:
                ok = messagebox.askyesno(
                    APP_NAME,
                    "This category is not empty.\n\nDelete it and EVERYTHING inside it?",
                    icon="warning"
                )
                if not ok:
                    return
                self._delete_category_recursive(cid)
            else:
                ok = messagebox.askyesno(APP_NAME, "Delete this category?", icon="warning")
                if not ok:
                    return
                self.db["categories"].pop(cid, None)

            save_db(self.db)
            self.status_var.set("Category deleted.")
            self.refresh_tree(select_id="cat_root")
            return

        iid = self.selected.id
        it = self.db["items"].get(iid)
        if not it:
            return

        ok = messagebox.askyesno(APP_NAME, "Delete this item?", icon="warning")
        if not ok:
            return

        if it["type"] == "file":
            p = Path(it.get("path", ""))
            if p.exists():
                delete_file = messagebox.askyesno(
                    APP_NAME,
                    "Also delete the stored file from disk?\n\n"
                    f"{p}",
                    icon="warning"
                )
                if delete_file:
                    try:
                        p.unlink()
                    except Exception as e:
                        messagebox.showwarning(APP_NAME, f"Could not delete file:\n{e}")

        self.db["items"].pop(iid, None)
        save_db(self.db)
        self.status_var.set("Item deleted.")
        self.refresh_tree(select_id="cat_root")

    def _delete_category_recursive(self, cid: str):
        to_delete_items = [iid for iid, it in self.db["items"].items() if it.get("category_id") == cid]
        for iid in to_delete_items:
            self.db["items"].pop(iid, None)

        subcats = [child_id for child_id, _ in category_children(self.db, cid)]
        for child_id in subcats:
            self._delete_category_recursive(child_id)

        self.db["categories"].pop(cid, None)

    # ----------------------------
    # Prompt helper
    # ----------------------------

    def _prompt(self, title: str, label: str, default: str = "") -> Optional[str]:
        d = SimplePrompt(self.root, title=title, label=label, default=default)
        return d.show()


# ----------------------------
# Dialogs
# ----------------------------

class SimplePrompt(tk.Toplevel):
    def __init__(self, master, title: str, label: str, default: str = ""):
        super().__init__(master)
        self.title(title)
        self.resizable(False, False)
        self.result: Optional[str] = None

        frm = ttk.Frame(self, padding=12)
        frm.pack(fill=tk.BOTH, expand=True)

        ttk.Label(frm, text=label).pack(anchor="w")
        self.var = tk.StringVar(value=default)
        ent = ttk.Entry(frm, textvariable=self.var, width=60)
        ent.pack(fill=tk.X, pady=(6, 10))
        ent.focus_set()
        ent.selection_range(0, tk.END)

        btns = ttk.Frame(frm)
        btns.pack(fill=tk.X)

        ttk.Button(btns, text="Cancel", command=self._cancel).pack(side=tk.RIGHT, padx=4)
        ttk.Button(btns, text="OK", command=self._ok).pack(side=tk.RIGHT)

        self.bind("<Return>", lambda e: self._ok())
        self.bind("<Escape>", lambda e: self._cancel())

        self.transient(master)
        self.grab_set()
        self.update_idletasks()
        self._center(master)

    def _center(self, master):
        self.update_idletasks()
        mx = master.winfo_rootx()
        my = master.winfo_rooty()
        mw = master.winfo_width()
        mh = master.winfo_height()
        w = self.winfo_width()
        h = self.winfo_height()
        x = mx + (mw - w) // 2
        y = my + (mh - h) // 2
        self.geometry(f"+{x}+{y}")

    def _ok(self):
        self.result = self.var.get()
        self.destroy()

    def _cancel(self):
        self.result = None
        self.destroy()

    def show(self) -> Optional[str]:
        self.wait_window()
        return self.result


class LinkDialog(tk.Toplevel):
    def __init__(self, master, title: str = "New Link"):
        super().__init__(master)
        self.title(title)
        self.resizable(False, False)
        self.result: Optional[Tuple[str, str, str]] = None

        frm = ttk.Frame(self, padding=12)
        frm.pack(fill=tk.BOTH, expand=True)

        self.title_var = tk.StringVar()
        self.url_var = tk.StringVar()

        ttk.Label(frm, text="Title (optional):").grid(row=0, column=0, sticky="w")
        ttk.Entry(frm, textvariable=self.title_var, width=62).grid(row=1, column=0, pady=(4, 10), sticky="we")

        ttk.Label(frm, text="URL (required):").grid(row=2, column=0, sticky="w")
        ttk.Entry(frm, textvariable=self.url_var, width=62).grid(row=3, column=0, pady=(4, 10), sticky="we")

        ttk.Label(frm, text="Notes (optional):").grid(row=4, column=0, sticky="w")
        notes = tk.Text(frm, width=62, height=6, wrap="word", relief="solid", borderwidth=1)
        notes.grid(row=5, column=0, pady=(4, 10), sticky="we")

        def pull_notes():
            return notes.get("1.0", tk.END).strip()

        btns = ttk.Frame(frm)
        btns.grid(row=6, column=0, sticky="e")

        ttk.Button(btns, text="Cancel", command=self._cancel).pack(side=tk.RIGHT, padx=4)
        ttk.Button(btns, text="Save", command=lambda: self._ok(pull_notes())).pack(side=tk.RIGHT)

        self.bind("<Escape>", lambda e: self._cancel())
        self.bind("<Return>", lambda e: self._ok(pull_notes()))

        self.transient(master)
        self.grab_set()
        self.update_idletasks()
        self._center(master)

    def _center(self, master):
        self.update_idletasks()
        mx = master.winfo_rootx()
        my = master.winfo_rooty()
        mw = master.winfo_width()
        mh = master.winfo_height()
        w = self.winfo_width()
        h = self.winfo_height()
        x = mx + (mw - w) // 2
        y = my + (mh - h) // 2
        self.geometry(f"+{x}+{y}")

    def _ok(self, notes_text: str):
        url = self.url_var.get().strip()
        if not url:
            messagebox.showwarning(APP_NAME, "URL is required.")
            return
        title = self.title_var.get().strip()
        self.result = (title, url, notes_text)
        self.destroy()

    def _cancel(self):
        self.result = None
        self.destroy()

    def show(self) -> Optional[Tuple[str, str, str]]:
        self.wait_window()
        return self.result


class RichNotesDialog(tk.Toplevel):
    """
    Rich-ish notes editor using Text tags:
    - Bold
    - Highlight
    - Apply font size to selection
    Stored as:
      notes_plain: string
      notes_tags: [{tag,start,end}, ...]
    """
    def __init__(self, master, title="Edit Notes", initial_plain="", initial_tags=None):
        super().__init__(master)
        self.title(title)
        self.geometry("820x560")
        self.minsize(680, 460)
        self.result = None

        frm = ttk.Frame(self, padding=10)
        frm.pack(fill=tk.BOTH, expand=True)

        tb = ttk.Frame(frm)
        tb.pack(fill=tk.X, pady=(0, 8))

        ttk.Button(tb, text="Bold", command=self.make_bold).pack(side=tk.LEFT, padx=4)
        ttk.Button(tb, text="Highlight", command=self.make_highlight).pack(side=tk.LEFT, padx=4)
        ttk.Button(tb, text="Clear Style", command=self.clear_style).pack(side=tk.LEFT, padx=4)

        ttk.Label(tb, text="Font size:").pack(side=tk.LEFT, padx=(14, 4))
        self.size_var = tk.IntVar(value=11)
        size_spin = ttk.Spinbox(
            tb, from_=8, to=32, textvariable=self.size_var, width=4,
            command=self.apply_font_size
        )
        size_spin.pack(side=tk.LEFT)

        text_wrap = ttk.Frame(frm)
        text_wrap.pack(fill=tk.BOTH, expand=True)

        self.text = tk.Text(text_wrap, wrap="word", relief="solid", borderwidth=1, font=("Segoe UI", 11))
        self.text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        y = ttk.Scrollbar(text_wrap, orient=tk.VERTICAL, command=self.text.yview)
        y.pack(side=tk.RIGHT, fill=tk.Y)
        self.text.configure(yscrollcommand=y.set)

        # tag styles
        base_font = tkfont.Font(font=self.text["font"])
        bold_font = base_font.copy()
        bold_font.configure(weight="bold")
        self.text.tag_configure("bold", font=bold_font)
        self.text.tag_configure("hl", background="#fff3a0")

        apply_text_with_tags(self.text, initial_plain or "", initial_tags or [])

        btns = ttk.Frame(frm)
        btns.pack(fill=tk.X, pady=(8, 0))
        ttk.Button(btns, text="Cancel", command=self.cancel).pack(side=tk.RIGHT, padx=4)
        ttk.Button(btns, text="Save", command=self.save).pack(side=tk.RIGHT)

        self.bind("<Escape>", lambda e: self.cancel())
        self.transient(master)
        self.grab_set()

    def _sel_range(self):
        try:
            return self.text.index("sel.first"), self.text.index("sel.last")
        except tk.TclError:
            return None

    def make_bold(self):
        r = self._sel_range()
        if not r:
            return
        self.text.tag_add("bold", r[0], r[1])

    def make_highlight(self):
        r = self._sel_range()
        if not r:
            return
        self.text.tag_add("hl", r[0], r[1])

    def clear_style(self):
        r = self._sel_range()
        if not r:
            return
        for tag in self.text.tag_names():
            if tag != "sel":
                self.text.tag_remove(tag, r[0], r[1])

    def apply_font_size(self):
        r = self._sel_range()
        if not r:
            return
        size = int(self.size_var.get())
        tag = f"size_{size}"

        # configure the tag if not already configured
        f = tkfont.Font(font=self.text["font"])
        f.configure(size=size)
        self.text.tag_configure(tag, font=f)

        self.text.tag_add(tag, r[0], r[1])

    def save(self):
        plain, tags = extract_text_with_tags(self.text)
        self.result = (plain, tags)
        self.destroy()

    def cancel(self):
        self.result = None
        self.destroy()

    def show(self):
        self.wait_window()
        return self.result


def main():
    ensure_dirs()
    root = tk.Tk()
    LinkDockApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()
