import sys
import time
import argparse
import shutil
from pathlib import Path
from typing import Iterable, List, Optional, Tuple

import ctypes
import win32con
import win32security
import win32api
import pythoncom
import pywintypes
import win32com.client


EXCEL_EXTS = {".xlsx", ".xlsm", ".xlsb", ".xls", ".xltx", ".xltm", ".xlt"}
WORD_EXTS = {".docx", ".docm", ".doc", ".dotx", ".dotm", ".dot"}
FILE_ATTRIBUTE_READONLY = 0x00000001
CALL_REJECTED_HRESULT = -2147418111  # "Call was rejected by callee"


# ---------- File enumeration ----------
def iter_all_files_recursive(root: Path) -> Iterable[Path]:
    for p in root.rglob("*"):
        if p.is_file():
            yield p


# ---------- Attributes ----------
def get_file_attrs(path: Path) -> int:
    return int(ctypes.windll.kernel32.GetFileAttributesW(str(path)))

def set_file_attrs(path: Path, attrs: int) -> None:
    ctypes.windll.kernel32.SetFileAttributesW(str(path), int(attrs))

def ensure_writable_for_save(path: Path) -> int:
    attrs = get_file_attrs(path)
    if attrs == -1:
        return -1
    if attrs & FILE_ATTRIBUTE_READONLY:
        set_file_attrs(path, attrs & ~FILE_ATTRIBUTE_READONLY)
    return attrs

def restore_attrs(path: Path, original_attrs: int) -> None:
    if original_attrs != -1:
        set_file_attrs(path, original_attrs)

def set_readonly_attribute(path: Path) -> None:
    attrs = get_file_attrs(path)
    if attrs == -1:
        return
    set_file_attrs(path, attrs | FILE_ATTRIBUTE_READONLY)


# ---------- NTFS permissions (SAFE) ----------
def lock_down_acl(path: Path) -> None:
    path_str = str(path)

    token = win32security.OpenProcessToken(win32api.GetCurrentProcess(), win32con.TOKEN_QUERY)
    user_sid = win32security.GetTokenInformation(token, win32security.TokenUser)[0]
    admin_sid, _, _ = win32security.LookupAccountName(None, r"BUILTIN\Administrators")

    dacl = win32security.ACL()
    dacl.AddAccessAllowedAceEx(win32security.ACL_REVISION, 0, win32con.GENERIC_ALL, user_sid)
    dacl.AddAccessAllowedAceEx(win32security.ACL_REVISION, 0, win32con.GENERIC_ALL, admin_sid)

    win32security.SetNamedSecurityInfo(
        path_str,
        win32security.SE_FILE_OBJECT,
        win32security.DACL_SECURITY_INFORMATION | win32security.PROTECTED_DACL_SECURITY_INFORMATION,
        None, None, dacl, None
    )


# ---------- COM retry ----------
def com_retry(fn, retries: int = 10, delay_s: float = 0.6):
    last_exc = None
    for _ in range(retries):
        try:
            return fn()
        except pywintypes.com_error as e:
            last_exc = e
            if len(e.args) >= 1 and e.args[0] == CALL_REJECTED_HRESULT:
                time.sleep(delay_s)
                continue
            raise
        except Exception as e:
            last_exc = e
            time.sleep(delay_s)
    raise last_exc


# ---------- Excel ----------
def start_excel_no_props():
    """
    Starts Excel via COM WITHOUT setting ANY application properties.
    This avoids your 'property cannot be set' errors.
    """
    pythoncom.CoInitialize()
    return com_retry(lambda: win32com.client.Dispatch("Excel.Application"))

def excel_fileformat_for_ext(ext: str) -> Optional[int]:
    # Helps Excel keep correct format when saving temp files
    ext = ext.lower()
    return {
        ".xlsx": 51,   # xlOpenXMLWorkbook
        ".xlsm": 52,   # xlOpenXMLWorkbookMacroEnabled
        ".xlsb": 50,   # xlExcel12
        ".xls": 56,    # xlExcel8
        ".xltx": 54,
        ".xltm": 53,
        ".xlt": 17,
    }.get(ext)

def set_excel_password_bulk(files: List[Path], password: str) -> Tuple[int, List[Tuple[Path, str]]]:
    if not files:
        return 0, []

    ok = 0
    errs: List[Tuple[Path, str]] = []
    excel = None

    try:
        excel = start_excel_no_props()

        for f in files:
            wb: Optional[object] = None
            orig_attrs = -1
            tmp = f.with_name(f"{f.stem}.__tmp_pw__{f.suffix}")

            try:
                orig_attrs = ensure_writable_for_save(f)
                if tmp.exists():
                    ensure_writable_for_save(tmp)
                    tmp.unlink()

                wb = com_retry(lambda: excel.Workbooks.Open(
                    str(f),
                    UpdateLinks=0,
                    ReadOnly=False,
                    IgnoreReadOnlyRecommended=True,
                    AddToMru=False
                ))

                ff = excel_fileformat_for_ext(f.suffix)
                if ff is None:
                    raise RuntimeError(f"Unsupported Excel extension: {f.suffix}")

                # Save temp WITH password-to-open
                com_retry(lambda: wb.SaveAs(str(tmp), FileFormat=ff, Password=password))
                com_retry(lambda: wb.Close(False))

                # Replace original
                ensure_writable_for_save(f)
                shutil.move(str(tmp), str(f))
                restore_attrs(f, orig_attrs)

                ok += 1
                print(f"Excel password set: {f}")

            except Exception as e:
                errs.append((f, f"{e.__class__.__name__}: {e}"))
                try:
                    if wb is not None:
                        com_retry(lambda: wb.Close(False))
                except Exception:
                    pass
                try:
                    if tmp.exists():
                        tmp.unlink()
                except Exception:
                    pass
                try:
                    restore_attrs(f, orig_attrs)
                except Exception:
                    pass

    finally:
        if excel is not None:
            try:
                com_retry(lambda: excel.Quit())
            except Exception:
                pass
        pythoncom.CoUninitialize()

    return ok, errs


# ---------- Word ----------
def start_word_no_props():
    pythoncom.CoInitialize()
    return com_retry(lambda: win32com.client.Dispatch("Word.Application"))

def set_word_password_bulk(files: List[Path], password: str) -> Tuple[int, List[Tuple[Path, str]]]:
    if not files:
        return 0, []

    ok = 0
    errs: List[Tuple[Path, str]] = []
    word = None

    try:
        word = start_word_no_props()

        for f in files:
            doc: Optional[object] = None
            orig_attrs = -1
            tmp = f.with_name(f"{f.stem}.__tmp_pw__{f.suffix}")

            try:
                orig_attrs = ensure_writable_for_save(f)
                if tmp.exists():
                    ensure_writable_for_save(tmp)
                    tmp.unlink()

                doc = com_retry(lambda: word.Documents.Open(
                    str(f),
                    ReadOnly=False,
                    AddToRecentFiles=False,
                    ConfirmConversions=False
                ))

                com_retry(lambda: doc.SaveAs2(str(tmp), Password=password))
                com_retry(lambda: doc.Close(False))

                ensure_writable_for_save(f)
                shutil.move(str(tmp), str(f))
                restore_attrs(f, orig_attrs)

                ok += 1
                print(f"Word password set: {f}")

            except Exception as e:
                errs.append((f, f"{e.__class__.__name__}: {e}"))
                try:
                    if doc is not None:
                        com_retry(lambda: doc.Close(False))
                except Exception:
                    pass
                try:
                    if tmp.exists():
                        tmp.unlink()
                except Exception:
                    pass
                try:
                    restore_attrs(f, orig_attrs)
                except Exception:
                    pass

    finally:
        if word is not None:
            try:
                com_retry(lambda: word.Quit())
            except Exception:
                pass
        pythoncom.CoUninitialize()

    return ok, errs


# ---------- Folder picker ----------
def pick_folder(initialdir: str) -> Path:
    import tkinter as tk
    from tkinter import filedialog
    root = tk.Tk()
    root.withdraw()
    folder = filedialog.askdirectory(initialdir=initialdir, title="Select folder to process (recursive)")
    root.destroy()
    if not folder:
        raise SystemExit("No folder selected.")
    return Path(folder)


# ---------- Main ----------
def main() -> None:
    ap = argparse.ArgumentParser(description="Recursively set Office passwords, then set readonly + ACL.")
    ap.add_argument("--folder", default="", help="Folder path (skip GUI picker).")
    ap.add_argument("--initialdir", default="C:/", help="Starting location for folder picker.")
    ap.add_argument("--password", default="password1234", help='Default is "password1234".')
    ap.add_argument("--no-acl", action="store_true", help="Skip NTFS permission changes.")
    ap.add_argument("--no-readonly", action="store_true", help="Skip read-only attribute changes.")
    ap.add_argument("--office-only", action="store_true", help="Apply readonly+ACL only to Word/Excel files.")

    args = ap.parse_args()

    root = Path(args.folder) if args.folder else pick_folder(args.initialdir)
    if not root.exists() or not root.is_dir():
        raise SystemExit(f"Invalid folder: {root}")

    all_files = list(iter_all_files_recursive(root))
    office_files = [p for p in all_files if p.suffix.lower() in EXCEL_EXTS or p.suffix.lower() in WORD_EXTS]
    excel_files = [p for p in office_files if p.suffix.lower() in EXCEL_EXTS]
    word_files = [p for p in office_files if p.suffix.lower() in WORD_EXTS]
    perm_targets = office_files if args.office_only else all_files

    print(f"\nProcessing: {root}")
    print(f"Total files: {len(all_files)}")
    print(f"Office files: {len(office_files)} (Excel={len(excel_files)}, Word={len(word_files)})")
    print("NOTE: CSV files cannot be Office-password-encrypted; only ACL/readonly applies to them.")
    print(f"Using password: {args.password}\n")

    # Passwords first
    x_ok, x_errs = set_excel_password_bulk(excel_files, args.password)
    w_ok, w_errs = set_word_password_bulk(word_files, args.password)

    print(f"\nExcel password OK: {x_ok}, errors: {len(x_errs)}")
    print(f"Word  password OK: {w_ok}, errors: {len(w_errs)}")

    if x_errs:
        print("\nExcel password errors (up to 10):")
        for p, msg in x_errs[:10]:
            print(f"  {p} -> {msg}")

    if w_errs:
        print("\nWord password errors (up to 10):")
        for p, msg in w_errs[:10]:
            print(f"  {p} -> {msg}")

    # Then readonly + ACL
    for f in perm_targets:
        if not args.no_readonly:
            try:
                set_readonly_attribute(f)
            except Exception as e:
                print(f"Readonly error: {f} -> {e}")

        if not args.no_acl:
            try:
                lock_down_acl(f)
            except Exception as e:
                print(f"ACL error: {f} -> {e}")

    print("\nDone.")
    sys.exit(1 if (x_errs or w_errs) else 0)


if __name__ == "__main__":
    main()
